@using AliveOnD_ID.Models
@using AliveOnD_ID.Services.Interfaces
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@inject IChatSessionService SessionService
@inject IAvatarStreamService AvatarService
@inject IJSRuntime JS

<div class="fullscreen-avatar-container">
    <!-- Full Background Avatar -->
    <div class="avatar-background">
        <video id="avatar-video" 
       class="avatar-video-fullscreen" 
       autoplay 
       playsinline 
       muted="false"
       style="opacity: 1; display: block;">
    Your browser does not support the video tag.
</video>
        
        <!-- Avatar Status Overlay (minimal) -->
        <div class="avatar-status-overlay">
            @if (AvatarStatus == StreamStatus.Connecting)
            {
                <div class="status-indicator connecting">
                    <div class="loading-spinner"></div>
                    <span>Connecting to avatar...</span>
                </div>
            }
            else if (AvatarStatus == StreamStatus.Error)
            {
                <div class="status-indicator error">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <span>Avatar connection failed</span>
                </div>
            }
            else if (AvatarStatus == StreamStatus.Connected)
            {
                <div class="status-indicator connected">
                    <div class="connected-icon">‚úÖ</div>
                    <span>Avatar ready</span>
                </div>
            }
        </div>
    </div>

    <!-- Chat Overlay (bottom 1/3 with fade) -->
    <div class="chat-overlay @(IsChatVisible ? "visible" : "hidden")">
        <!-- Chat Header (minimal) -->
        <div class="chat-overlay-header">
            <h4>Chat with AI Avatar</h4>
            <button class="chat-toggle-btn" @onclick="ToggleChatVisibility">
                @(IsChatVisible ? "‚àí" : "üí¨")
            </button>
        </div>

        <!-- Messages Area -->
        <div class="messages-overlay-container" id="messages-container">
            @if (Messages != null && Messages.Any())
            {
                @foreach (var message in Messages)
                {
                    <div class="message-bubble @(message.Type == MessageType.UserText || message.Type == MessageType.UserAudio ? "user-bubble" : "ai-bubble")">
                        <div class="bubble-content">
                            @if (message.Type == MessageType.UserAudio)
                            {
                                <div class="audio-message-content">
                                    <span class="audio-icon">üé§</span>
                                    <span>@message.Content</span>
                                    @if (!string.IsNullOrEmpty(message.AudioUrl))
                                    {
                                        <audio controls class="audio-player">
                                            <source src="@message.AudioUrl" type="audio/mpeg">
                                        </audio>
                                    }
                                </div>
                            }
                            else
                            {
                                <p>@message.Content</p>
                            }
                            
                            @if (message.Status == MessageStatus.Processing)
                            {
                                <div class="typing-indicator">
                                    <span></span><span></span><span></span>
                                </div>
                            }
                            else if (message.Status == MessageStatus.Failed)
                            {
                                <span class="message-error">Failed to send</span>
                            }
                        </div>
                        <div class="bubble-time">
                            @message.Timestamp.ToString("HH:mm")
                        </div>
                    </div>
                }
            }
            else
            {
                <div class="welcome-message">
                    <p>üëã Your AI avatar is @(AvatarStatus == StreamStatus.Connected ? "ready" : "connecting")! Start chatting!</p>
                </div>
            }
            
            @if (!string.IsNullOrEmpty(ConnectionError))
            {
                <div class="error-message">
                    <p>‚ö†Ô∏è @ConnectionError</p>
                    <button class="retry-btn" @onclick="RetryConnection">Retry Connection</button>
                </div>
            }
        </div>
    </div>

    <!-- Bottom Controls (always visible) -->
    <div class="bottom-controls">
        <!-- Voice Recording Button -->
        <div class="voice-control-section">
            <button class="voice-record-btn @(IsRecording ? "recording" : "")" 
                    @onclick="ToggleRecording"
                    disabled="@(IsProcessing || AvatarStatus != StreamStatus.Connected)">
                @if (IsRecording)
                {
                    <div class="record-icon recording-icon">‚èπÔ∏è</div>
                }
                else
                {
                    <div class="record-icon">üé§</div>
                }
            </button>
            
            <!-- Recording Feedback -->
            @if (IsRecording)
            {
                <div class="recording-feedback-overlay">
                    <div class="recording-timer">@RecordingTime</div>
                    <div class="waveform-visualizer">
                        <div class="wave-bar"></div>
                        <div class="wave-bar"></div>
                        <div class="wave-bar"></div>
                        <div class="wave-bar"></div>
                        <div class="wave-bar"></div>
                        <div class="wave-bar"></div>
                        <div class="wave-bar"></div>
                    </div>
                    <div class="recording-instruction">Tap to stop recording</div>
                </div>
            }
        </div>

        <!-- Optional Text Input (can be hidden/minimized) -->
        <div class="text-input-section @(ShowTextInput ? "visible" : "hidden")">
            <div class="text-input-container">
                <input type="text" 
                       @bind="CurrentMessage" 
                       @onkeypress="HandleKeyPress"
                       placeholder="Type a message..." 
                       disabled="@(IsProcessing || AvatarStatus != StreamStatus.Connected)"
                       class="overlay-text-input" />
                <button class="send-text-btn" 
                        @onclick="SendTextMessage" 
                        disabled="@(IsProcessing || string.IsNullOrWhiteSpace(CurrentMessage) || AvatarStatus != StreamStatus.Connected)">
                    ‚û§
                </button>
            </div>
            <button class="toggle-text-input" @onclick="ToggleTextInput">
                @(ShowTextInput ? "üé§" : "‚å®Ô∏è")
            </button>
        </div>
    </div>
</div>

@code {
    [Parameter] public string? SessionId { get; set; }
    [Parameter] public string? UserId { get; set; }

    private List<ChatMessage> Messages = new();
    private string CurrentMessage = string.Empty;
    private bool IsRecording = false;
    private bool IsProcessing = false;
    private bool IsAvatarSpeaking = false;
    private bool IsChatVisible = true;
    private bool ShowTextInput = true; // Start with text input visible
    private StreamStatus AvatarStatus = StreamStatus.Disconnected;
    private string RecordingTime = "00:00";
    private string ConnectionError = string.Empty;
    
    // Avatar stream data
    private string? AvatarStreamId;
    private string? AvatarSessionId;
    private DIDStreamResponse? StreamResponse;

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(SessionId))
        {
            await LoadSession();
        }
        else
        {
            await CreateNewSession();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Auto-connect to D-ID avatar after first render
            await ConnectToAvatar();
        }
    }

    private async Task ConnectToAvatar()
    {
        try
        {
            AvatarStatus = StreamStatus.Connecting;
            ConnectionError = string.Empty;
            StateHasChanged();

            // Create D-ID stream
            StreamResponse = await AvatarService.CreateStreamAsync();
            AvatarStreamId = StreamResponse.Id;
            AvatarSessionId = StreamResponse.SessionId;

            Console.WriteLine($"D-ID Stream created: {AvatarStreamId}");

            // Initialize WebRTC connection via JavaScript
            var success = await JS.InvokeAsync<bool>("initializeAvatarStream", 
                StreamResponse.IceServers, StreamResponse.Offer);

            Console.WriteLine($"WebRTC initialization result: {success}");

            if (success)
            {
                // Get the SDP answer from JavaScript
                var sdpAnswer = await JS.InvokeAsync<object>("getSdpAnswer");
                
                if (sdpAnswer != null)
                {
                    Console.WriteLine("Sending SDP answer to D-ID...");
                    
                    // Send SDP answer to D-ID
                    var streamStarted = await AvatarService.StartStreamAsync(AvatarStreamId, AvatarSessionId, sdpAnswer);
                    
                    if (streamStarted)
                    {
                        Console.WriteLine("D-ID stream started successfully");
                        
                        // Wait a moment for the stream to initialize
                        await Task.Delay(3000);
                        
                        // Send a test message to activate the avatar video
                        Console.WriteLine("Sending test message to activate avatar...");
                        await SendTextToAvatar("Hello! I am your AI assistant. I am now ready to help you.");
                        
                        AvatarStatus = StreamStatus.Connected;
                        StateHasChanged();
                    }
                    else
                    {
                        AvatarStatus = StreamStatus.Error;
                        ConnectionError = "Failed to start D-ID stream";
                    }
                }
                else
                {
                    AvatarStatus = StreamStatus.Error;
                    ConnectionError = "Failed to get SDP answer from WebRTC";
                }
            }
            else
            {
                AvatarStatus = StreamStatus.Error;
                ConnectionError = "Failed to establish WebRTC connection";
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            AvatarStatus = StreamStatus.Error;
            ConnectionError = $"Connection failed: {ex.Message}";
            Console.WriteLine($"Avatar connection error: {ex}");
            StateHasChanged();
        }
    }

    private async Task RetryConnection()
    {
        await ConnectToAvatar();
    }

    private async Task LoadSession()
    {
        try
        {
            var session = await SessionService.GetSessionAsync(SessionId!);
            if (session != null)
            {
                Messages = session.Messages;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading session: {ex.Message}");
        }
    }

    private async Task CreateNewSession()
    {
        try
        {
            var userId = UserId ?? $"user_{Guid.NewGuid():N}";
            var session = await SessionService.CreateSessionAsync(userId);
            SessionId = session.SessionId;
            UserId = session.UserId;
            Messages = session.Messages;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error creating session: {ex.Message}");
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(CurrentMessage))
        {
            await SendTextMessage();
        }
    }

    private async Task SendTextMessage()
    {
        if (string.IsNullOrWhiteSpace(CurrentMessage) || IsProcessing || AvatarStatus != StreamStatus.Connected)
            return;

        IsProcessing = true;
        var messageText = CurrentMessage.Trim();
        CurrentMessage = string.Empty;

        try
        {
            // Add user message
            var userMessage = new ChatMessage
            {
                Type = MessageType.UserText,
                Content = messageText,
                Status = MessageStatus.Completed
            };

            Messages.Add(userMessage);
            await SessionService.AddMessageAsync(SessionId!, userMessage);

            // Add processing indicator for AI response
            var aiMessage = new ChatMessage
            {
                Type = MessageType.AssistantText,
                Content = "Thinking...",
                Status = MessageStatus.Processing
            };
            Messages.Add(aiMessage);
            StateHasChanged();

            // Scroll to bottom
            await ScrollToBottom();

            // TODO: Get LLM response - for now using mock response
            await Task.Delay(1000); // Simulate LLM processing

            // Update AI message with response
            var responseText = $"I understand you said: \"{messageText}\". This is a test response while we integrate the full LLM service.";
            aiMessage.Content = responseText;
            aiMessage.Status = MessageStatus.Completed;
            await SessionService.UpdateMessageAsync(SessionId!, aiMessage);

            // Send response to avatar
            await SendTextToAvatar(responseText);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending message: {ex.Message}");
        }
        finally
        {
            IsProcessing = false;
        }
    }

    private async Task SendTextToAvatar(string text)
    {
        if (AvatarStatus != StreamStatus.Connected || string.IsNullOrEmpty(AvatarStreamId) || string.IsNullOrEmpty(AvatarSessionId))
            return;

        try
        {
            AvatarStatus = StreamStatus.Speaking;
            StateHasChanged();

            var success = await AvatarService.SendTextToAvatarAsync(AvatarStreamId, AvatarSessionId, text);
            
            if (!success)
            {
                Console.WriteLine("Failed to send text to avatar");
            }

            // Reset status after a delay (avatar speaking time)
            await Task.Delay(3000);
            AvatarStatus = StreamStatus.Connected;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error sending text to avatar: {ex.Message}");
            AvatarStatus = StreamStatus.Connected;
            StateHasChanged();
        }
    }

    private async Task ToggleRecording()
    {
        if (IsRecording)
        {
            await StopRecording();
        }
        else
        {
            await StartRecording();
        }
    }

    private async Task StartRecording()
    {
        try
        {
            IsRecording = true;
            await JS.InvokeVoidAsync("startAudioRecording");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error starting recording: {ex.Message}");
            IsRecording = false;
        }
    }

    private async Task StopRecording()
    {
        try
        {
            IsRecording = false;
            await JS.InvokeVoidAsync("stopAudioRecording");
            StateHasChanged();

            // TODO: Process audio recording
            await Task.Delay(1000);

            var audioMessage = new ChatMessage
            {
                Type = MessageType.UserAudio,
                Content = "Voice message (transcribed)",
                Status = MessageStatus.Completed,
                AudioUrl = "/audio/sample.mp3"
            };

            Messages.Add(audioMessage);
            await SessionService.AddMessageAsync(SessionId!, audioMessage);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error stopping recording: {ex.Message}");
        }
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JS.InvokeVoidAsync("scrollToBottom", "messages-container");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error scrolling: {ex.Message}");
        }
    }

    private void ToggleChatVisibility()
    {
        IsChatVisible = !IsChatVisible;
        StateHasChanged();
    }

    private void ToggleTextInput()
    {
        ShowTextInput = !ShowTextInput;
        StateHasChanged();
    }

    // JavaScript interop methods for handling WebRTC callbacks
    [JSInvokable]
    public static async Task HandleConnectionStateChange(string state)
    {
        Console.WriteLine($"WebRTC connection state: {state}");
    }

    [JSInvokable] 
    public static async Task HandleIceCandidate(object candidate)
    {
        Console.WriteLine("ICE candidate received");
        // TODO: Send ICE candidate to D-ID if needed
    }

    [JSInvokable]
    public static async Task HandleAudioData(object audioData)
    {
        Console.WriteLine("Audio data received from recording");
        // TODO: Process recorded audio
    }
}